Act as a seniour WebApplication developer on NextJs with PWA and you have to use typescript for development.

Here is 4 example of file, I will provide...

1. api/route.ts
    ```   
    import { handleRateLimit } from '@/app/api/utils/rate-limit';
    import { getFinances, createFinance, updateFinance, deleteFinance, getFinanceById, bulkUpdateFinances, bulkDeleteFinances } from './controller';

    import { formatResponse, IResponse } from '@/app/api/utils/jwt-verify';

    // GET all Finances
    export async function GET(req: Request) {
    const rateLimitResponse = handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    // const tokenResponse = handleTokenVerify(req);
    // if (tokenResponse) return tokenResponse;

    const id = new URL(req.url).searchParams.get('id');
    const result: IResponse = id ? await getFinanceById(req) : await getFinances(req);
    return formatResponse(result.data, result.message, result.status);
    }

    // CREATE Finance
    export async function POST(req: Request) {
    const rateLimitResponse = handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    // const tokenResponse = handleTokenVerify(req);
    // if (tokenResponse) return tokenResponse;

    const result = await createFinance(req);
    return formatResponse(result.data, result.message, result.status);
    }

    // UPDATE Finance
    export async function PUT(req: Request) {
    const rateLimitResponse = handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    // const tokenResponse = handleTokenVerify(req);
    // if (tokenResponse) return tokenResponse;

    const isBulk = new URL(req.url).searchParams.get('bulk') === 'true';
    const result = isBulk ? await bulkUpdateFinances(req) : await updateFinance(req);

    return formatResponse(result.data, result.message, result.status);
    }

    // DELETE Finance
    export async function DELETE(req: Request) {
    const rateLimitResponse = handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    // const tokenResponse = handleTokenVerify(req);
    // if (tokenResponse) return tokenResponse;

    const isBulk = new URL(req.url).searchParams.get('bulk') === 'true';
    const result = isBulk ? await bulkDeleteFinances(req) : await deleteFinance(req);

    return formatResponse(result.data, result.message, result.status);
    }
```

2. api/model.ts 
```
import mongoose, { Schema } from 'mongoose';

const financeSchema = new Schema(
  {
    studentName: { type: String },
    studentEinfo: {
      type: String,
      unique: false,
    },
    studentNumber: { type: String },
    courseName: { type: String },
    coursePrice: { type: String },
    coureCode: { type: String },
    batchNo: { type: String },
    paymentStatus: { type: Boolean, default: false },
    discount: { type: String },
    totalPayment: { type: String },
    enrollmentDate: { type: Date, default: Date.now },
    paymentData: { type: Date, default: Date.now },
    verifyWhomName: { type: String },
    verifyWhomEinfo: {
      type: String,
    },
    transectionId: { type: String },
    invoiceNumber: { type: String },
    refundStatus: { type: Boolean, default: false },
    refundAmount: { type: String },
  },
  { timestamps: true },
);

const PaymentFinance = mongoose.models.PaymentFinance || mongoose.model('PaymentFinance', financeSchema);
export default PaymentFinance;

```

3. api/controller.ts
```
import { withDB } from '@/app/api/utils/db';

import PaymentFinance from './model';

interface IResponse {
  data: unknown;
  message: string;
  status: number;
}

// Helper to format responses
const formatResponse = (data: unknown, message: string, status: number): IResponse => ({
  data,
  message,
  status,
});

// CREATE Finance
export async function createFinance(req: Request): Promise<IResponse> {
  return withDB(async () => {
    try {
      const financeData = await req.json();
      const newFinance = await PaymentFinance.create({
        ...financeData,
      });
      return formatResponse(newFinance, 'Finance created successfully', 201);
    } catch (error: unknown) {
      if ((error as { code?: number }).code === 11000) {
        const err = error as { keyValue?: Record<string, unknown> };
        return formatResponse(null, `Duplicate key error: ${JSON.stringify(err.keyValue)}`, 400);
      }
      throw error; // Re-throw other errors to be handled by `withDB`
    }
  });
}

// GET single Finance by ID
export async function getFinanceById(req: Request): Promise<IResponse> {
  return withDB(async () => {
    const id = new URL(req.url).searchParams.get('id');
    if (!id) return formatResponse(null, 'Finance ID is required', 400);

    const finance = await PaymentFinance.findById(id);
    if (!finance) return formatResponse(null, 'Finance not found', 404);

    return formatResponse(finance, 'Finance fetched successfully', 200);
  });
}

// GET all Finances with pagination
export async function getFinances(req: Request): Promise<IResponse> {
  return withDB(async () => {
    const url = new URL(req.url);
    const page = parseInt(url.searchParams.get('page') || '1', 10);
    const limit = parseInt(url.searchParams.get('limit') || '10', 10);
    const skip = (page - 1) * limit;

    const searchQuery = url.searchParams.get('q');

    let searchFilter = {};

    // Apply search filter only if a search query is provided
    if (searchQuery) {
      searchFilter = {
        $or: [
          { studentName: { $regex: searchQuery, $options: 'i' } },
          { studentEinfo: { $regex: searchQuery, $options: 'i' } },
          { studentNumber: { $regex: searchQuery, $options: 'i' } },
          { courseName: { $regex: searchQuery, $options: 'i' } },
          { coureCode: { $regex: searchQuery, $options: 'i' } },
          { batchNo: { $regex: searchQuery, $options: 'i' } },
          { verifyWhomName: { $regex: searchQuery, $options: 'i' } },
          { verifyWhomEinfo: { $regex: searchQuery, $options: 'i' } },
          { transectionId: { $regex: searchQuery, $options: 'i' } },
          { invoiceNumber: { $regex: searchQuery, $options: 'i' } },
        ],
      };
    }

    const finances = await PaymentFinance.find(searchFilter).sort({ updatedAt: -1, createdAt: -1 }).skip(skip).limit(limit);

    const totalFinances = await PaymentFinance.countDocuments(searchFilter);

    return formatResponse(
      {
        finances: finances || [],
        total: totalFinances,
        page,
        limit,
      },
      'Finances fetched successfully',
      200,
    );
  });
}

// UPDATE single Finance by ID
export async function updateFinance(req: Request): Promise<IResponse> {
  return withDB(async () => {
    try {
      const { id, ...updateData } = await req.json();
      const updatedFinance = await PaymentFinance.findByIdAndUpdate(id, updateData, { new: true, runValidators: true });

      if (!updatedFinance) return formatResponse(null, 'Finance not found', 404);
      return formatResponse(updatedFinance, 'Finance updated successfully', 200);
    } catch (error: unknown) {
      if ((error as { code?: number }).code === 11000) {
        const err = error as { keyValue?: Record<string, unknown> };
        return formatResponse(null, `Duplicate key error: ${JSON.stringify(err.keyValue)}`, 400);
      }
      throw error; // Re-throw other errors to be handled by `withDB`
    }
  });
}

// BULK UPDATE Finances
export async function bulkUpdateFinances(req: Request): Promise<IResponse> {
  return withDB(async () => {
    const updates: { id: string; updateData: Record<string, unknown> }[] = await req.json();
    const results = await Promise.allSettled(
      updates.map(({ id, updateData }) =>
        PaymentFinance.findByIdAndUpdate(id, updateData, {
          new: true,
          runValidators: true,
        }),
      ),
    );

    const successfulUpdates = results.filter((r): r is PromiseFulfilledResult<unknown> => r.status === 'fulfilled' && r.value).map(r => r.value);

    const failedUpdates = results
      .map((r, i) => (r.status === 'rejected' || !('value' in r && r.value) ? updates[i].id : null))
      .filter((id): id is string => id !== null);

    return formatResponse({ updated: successfulUpdates, failed: failedUpdates }, 'Bulk update completed', 200);
  });
}

// DELETE single Finance by ID
export async function deleteFinance(req: Request): Promise<IResponse> {
  return withDB(async () => {
    const { id } = await req.json();
    const deletedFinance = await PaymentFinance.findByIdAndDelete(id);
    if (!deletedFinance) return formatResponse(null, 'Finance not found', 404);
    return formatResponse({ deletedCount: 1 }, 'Finance deleted successfully', 200);
  });
}

// BULK DELETE Finances
export async function bulkDeleteFinances(req: Request): Promise<IResponse> {
  return withDB(async () => {
    const { ids }: { ids: string[] } = await req.json();
    const deletedIds: string[] = [];
    const invalidIds: string[] = [];

    for (const id of ids) {
      try {
        const doc = await PaymentFinance.findById(id);
        if (doc) {
          const deletedDoc = await PaymentFinance.findByIdAndDelete(id);
          if (deletedDoc) {
            deletedIds.push(id);
          }
        } else {
          invalidIds.push(id);
        }
      } catch {
        invalidIds.push(id);
      }
    }

    return formatResponse({ deleted: deletedIds.length, deletedIds, invalidIds }, 'Bulk delete operation completed', 200);
  });
}

```

4. app/page.tsx
```
'use client';

import React, { useState } from 'react';
import { PlusIcon } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { FetchBaseQueryError } from '@reduxjs/toolkit/query';

import { useFinancesStore } from './store/store';
import TooManyRequests from './components/TooManyRequest';
import SearchBox from './components/SearchBox';
import { useGetfinancesQuery } from './redux/rtk-api';
import ViewFinancesTable from './components/TableView';

// import BulkEditFile from './components/BulkEdit';
import AddFile from './components/Add';
import EditFile from './components/Edit';
import ViewFile from './components/View';
import DeleteFile from './components/Delete';
import BulkDeleteFile from './components/BulkDelete';
// import BulkUpdateFinances from './components/BulkUpdate';
// import BulkDynamicUpdateFinances from './components/BulkDynamicUpdate';

const MainNextPage: React.FC = () => {
  const [hashSearchText, setHashSearchText] = useState('');
  const { toggleAddModal, queryPramsLimit, queryPramsPage, queryPramsQ, setQueryPramsPage, setQueryPramsQ } = useFinancesStore();

  const {
    data: getResponseData,
    isSuccess,
    status: statusCode,
  } = useGetfinancesQuery(
    { q: queryPramsQ, page: queryPramsPage, limit: queryPramsLimit },
    {
      selectFromResult: ({ data, isSuccess, status, error }) => ({
        data,
        isSuccess,
        status: 'status' in (error || {}) ? (error as FetchBaseQueryError).status : status, // Extract HTTP status code
        error,
      }),
    },
  );

  const handleSearch = (query: string) => {
    if (query !== hashSearchText) {
      setHashSearchText(query);
      setQueryPramsPage(1);
      setQueryPramsQ(query);
    }
  };

  // const modals = [  BulkEditFile, , , BulkUpdateFinances, BulkDynamicUpdateFinances];
  const modals = [ViewFile, AddFile, BulkDeleteFile, EditFile, DeleteFile];

  let renderUI = (
    <div className="container mx-auto p-4">
      <div className="flex flex-col md:flex-row gap-2 justify-between items-center mb-6">
        <h1 className="h2 w-full">Finance Management {isSuccess && <sup className="text-xs">(total:{getResponseData?.data?.total || '00'})</sup>}</h1>
        <div className="w-full flex flex-col md:flex-row gap-2 item-center justify-end">
          <Button size="sm" variant="outlineGarden" onClick={() => toggleAddModal(true)}>
            <PlusIcon className="w-4 h-4" />
            Add New Payment
          </Button>
        </div>
      </div>
      <SearchBox onSearch={handleSearch} placeholder="Search here ..." autoFocus={false} />
      <ViewFinancesTable />
      {modals.map((ModalComponent, index) => (
        <ModalComponent key={index} />
      ))}
    </div>
  );

  if (statusCode === 429) {
    renderUI = <TooManyRequests />;
  }

  return renderUI;
};

export default MainNextPage;

```

--- Now Please generate a overview page.tsx for overview of finance.
    I need some following things
        1. Total Payment
        2. Total Dew
        3. Total Discount
        4. Total Transections

        5. Last Month (1/8/2025 - 31/8/2025) Payment
        6. Last Month (1/8/2025 - 31/8/2025) Dew
        7. Last Month (1/8/2025 - 31/8/2025) Discount
        8. Last Month (1/8/2025 - 31/8/2025) Transections

--- please make sure that it is responsive for mobile, tablet, and desktop. also make sure that it looks eye-catching-view. a little bit animation. and use glassy effect card for display those 8 component. also make sure you make it for NextJs with Typescript.

--- if you want to use any other card for better experience or any field you can use it or generate it. 
--- if you need a new api for finance-overview you can do it. 